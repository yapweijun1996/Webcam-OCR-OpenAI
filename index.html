<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Vanilla Webcam OCR (Responses API)</title>
<style>
  :root { --pad:16px; --max-w:800px; }
  * { box-sizing:border-box; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  body { margin:0; background:#f8fafc; color:#1f2937; line-height:1.5; }

  /* Mobile-first responsive design */
  .wrap {
    max-width:var(--max-w); margin:0 auto; padding:var(--pad);
    display:grid; gap:calc(var(--pad) * 0.75);
    grid-template-columns: 1fr;
  }

  /* Desktop layout for larger screens */
  @media (min-width: 768px) {
    .wrap { grid-template-columns: 1fr 1fr; gap:var(--pad); }
    .video-section { grid-column:1 / -1; }
    .ocr-section { grid-column:1; }
    .metrics-section { grid-column:2; }
    .cost-section { grid-column:1 / -1; }
  }

  /* Controls bar */
  .bar {
    display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    padding:12px; background:#fff; border-radius:12px; box-shadow:0 1px 3px rgba(0,0,0,0.1);
  }
  button, select {
    padding:8px 16px; border:1px solid #d1d5db; background:#fff; border-radius:8px;
    font-size:14px; cursor:pointer; transition: all 0.2s;
  }
  button:hover { background:#f9fafb; }
  button.primary { background:#1f2937; color:#fff; border-color:#1f2937; }
  button.primary:hover { background:#111827; }

  /* Video section with sticky positioning */
  .video-box {
    position:sticky; top:16px; background:#000; border-radius:12px; overflow:hidden;
    box-shadow:0 4px 6px rgba(0,0,0,0.1); aspect-ratio:16/9;
  }
  video { width:100%; height:100%; object-fit:cover; display:block; }
  .hud {
    position:absolute; left:0; right:0; bottom:0; display:flex; justify-content:space-between; gap:8px;
    padding:12px; color:#fff; background:linear-gradient(180deg,transparent,rgba(0,0,0,.7));
  }

  /* Cards */
  .card {
    background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:16px;
    box-shadow:0 1px 3px rgba(0,0,0,0.1); transition: box-shadow 0.2s;
  }
  .card:hover { box-shadow:0 4px 6px rgba(0,0,0,0.1); }
  .label {
    font-size:12px; color:#6b7280; font-weight:600; margin-bottom:8px;
    display:flex; align-items:center; gap:4px;
  }
  .value {
    font-size:14px; white-space:pre-wrap; line-height:1.5; max-height:200px; overflow-y:auto;
    color:#1f2937;
  }

  /* Cost section styling */
  .cost-container { display:grid; gap:6px; }
  .cost-main { font-size:20px; font-weight:700; color:#2563eb; }
  .cost-breakdown { font-size:11px; color:#6b7280; margin-top:2px; }
  .cost-indicator {
    font-size:10px; text-align:center; margin-top:4px; padding:2px 8px; border-radius:12px;
    display:inline-block; font-weight:500;
  }
  .cost-low { background:#dcfce7; color:#166534; }
  .cost-medium { background:#fef3c7; color:#92400e; }
  .cost-high { background:#fecaca; color:#991b1b; }

  /* Token table */
  .token-table-container { margin-top:12px; }
  .token-table {
    width:100%; border-collapse:collapse; font-size:12px; background:#f9fafb; border-radius:6px; overflow:hidden;
  }
  .token-table th {
    background:#e5e7eb; color:#374151; font-weight:600; padding:8px 6px; text-align:center; font-size:11px;
  }
  .token-table td {
    padding:6px; text-align:center; font-weight:500; border-top:1px solid #f3f4f6;
  }
  .token-input { color:#059669; }
  .token-output { color:#dc2626; }
  .token-total { color:#2563eb; font-weight:700; }

  /* History section */
  .history-container {
    margin-top:8px; max-height:120px; overflow-y:auto; font-size:11px; color:#6b7280;
    border-top:1px solid #f3f4f6; padding-top:8px;
  }
  .history-header { font-weight:600; margin-bottom:6px; color:#374151; }
  .history-item { margin:4px 0; padding:4px; border-radius:4px; cursor:pointer; transition: background 0.2s; }
  .history-item:hover { background:#f9fafb; }

  /* Notes and tips */
  .note {
    font-size:12px; color:#6b7280; text-align:center; padding:8px;
    background:#f9fafb; border-radius:8px; border:1px solid #f3f4f6;
  }

  /* Mobile optimizations */
  @media (max-width: 480px) {
    :root { --pad:12px; }
    .bar { padding:8px; gap:6px; }
    button, select { padding:6px 12px; font-size:13px; }
    .card { padding:12px; }
    .video-box { aspect-ratio:4/3; }
    .hud { padding:8px; font-size:11px; }
  }
  .note { font-size:12px; color:#666; }
  .hidden { display:none !important; }
</style>
</head>
<body>
<div class="wrap">
  <!-- Control Panel -->
  <div class="bar">
    <button id="apiBtn">API</button>
    <select id="model">
      <option value="gpt-5-mini">ü§ñ GPT-5-Mini ($0.25/$2.00)</option>
      <option value="gpt-5-nano" selected>‚ö° GPT-5-Nano ($0.05/$0.40)</option>
    </select>
    <select id="facing">
      <option value="environment">üì∑ Rear camera</option>
      <option value="user">ü§≥ Front camera</option>
    </select>
    <button id="startBtn" class="primary">‚ñ∂Ô∏è Start</button>
    <button id="stopBtn">‚èπÔ∏è Stop</button>
    <span class="note" id="status">idle</span>
  </div>

  <!-- Video Section (Sticky) -->
  <div class="video-section">
    <div class="video-box">
      <video id="video" playsinline autoplay muted></video>
      <div class="hud">
        <span class="note">ü§ñ Auto-scanning‚Ä¶ (sequential)</span>
        <span class="note" id="meta">‚Äî</span>
      </div>
    </div>
  </div>

  <!-- OCR Text Section -->
  <div class="card ocr-section">
    <div class="label">üìù OCR Text Record</div>
    <div class="value" id="ocr">‚Äî</div>
    <div class="history-container" id="history-container">
      <div class="history-header">üìö Recent captures:</div>
      <div id="history-list">No previous captures</div>
    </div>
  </div>

  <!-- Performance Metrics -->
  <div class="card metrics-section">
    <div class="label">
      üìä Performance Metrics
      <button onclick="toggleMetricsHelp()" style="background: none; border: none; color: #6b7280; font-size: 12px; cursor: pointer; margin-left: 8px;" title="Show/hide help">‚ùì</button>
    </div>
    <div class="metrics-container">
      <div class="performance-badge" style="background: #dbeafe; color: #1e40af; padding: 4px 8px; border-radius: 6px; font-size: 10px; font-weight: 600; margin-bottom: 8px; display: inline-block;">
        ‚ö° Speed Optimized
      </div>
      <div class="metrics-summary" id="metrics-display">‚Äî</div>

      <!-- Metrics Help Section -->
      <div id="metrics-help" class="metrics-help" style="display: none; margin-top: 8px; font-size: 11px; color: #6b7280; line-height: 1.4; padding: 8px; background: #f9fafb; border-radius: 6px; border: 1px solid #f3f4f6;">
        <div style="margin: 4px 0;"><strong>bin:XXKB</strong> ‚Äî Compressed image size sent to API</div>
        <div style="margin: 4px 0;"><strong>api:XXXms</strong> ‚Äî Current API response time</div>
        <div style="margin: 4px 0;"><strong>avg:XXXms</strong> ‚Äî Average API response time</div>
        <div style="margin: 4px 0;"><strong>interval:XXXms</strong> ‚Äî Time between scans (auto-adjusted)</div>
        <div style="margin: 4px 0;"><strong>tokens:XXX</strong> ‚Äî Total tokens used in current API call</div>
      </div>
      <div class="token-table-container" id="token-table-container" style="display: none;">
        <table class="token-table">
          <thead>
            <tr>
              <th></th>
              <th>Input</th>
              <th>Output</th>
              <th>Total</th>
            </tr>
          </thead>
          <tbody id="token-table-body">
            <tr class="current-row">
              <td><small>Current</small></td>
              <td id="input-tokens" class="token-input">‚Äî</td>
              <td id="output-tokens" class="token-output">‚Äî</td>
              <td id="total-tokens" class="token-total">‚Äî</td>
            </tr>
            <tr class="cumulative-row" style="border-top: 2px solid #e5e7eb;">
              <td><small><strong>Session</strong></small></td>
              <td id="cumulative-input" class="token-input"><strong>‚Äî</strong></td>
              <td id="cumulative-output" class="token-output"><strong>‚Äî</strong></td>
              <td id="cumulative-total" class="token-total"><strong>‚Äî</strong></td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- API Time Table -->
      <div class="api-time-container" id="api-time-container" style="display: none; margin-top: 12px;">
        <table class="token-table">
          <thead>
            <tr>
              <th></th>
              <th>Current</th>
              <th>Average</th>
              <th>Scans</th>
            </tr>
          </thead>
          <tbody id="api-time-table-body">
            <tr class="current-row">
              <td><small>API Time</small></td>
              <td id="current-api-time" class="token-total">‚Äî</td>
              <td id="average-api-time" class="token-total">‚Äî</td>
              <td id="api-scan-count" class="token-total">‚Äî</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Cost Analysis -->
  <div class="card cost-section">
    <div class="label">üí∞ Estimated Cost</div>
    <div class="cost-container">
      <div class="cost-main" id="cost-main">‚Äî</div>
      <div class="cost-breakdown" id="cost-breakdown">Calculating...</div>
      <div class="cost-indicator" id="cost-indicator"></div>

      <!-- Cumulative Cost Section -->
      <div class="cumulative-cost" id="cumulative-cost-section" style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #f3f4f6; display: none;">
        <div class="cost-main" style="font-size: 16px; color: #059669;" id="cumulative-cost-main">‚Äî</div>
        <div class="cost-breakdown" style="font-size: 10px; color: #6b7280;" id="cumulative-cost-breakdown">Session total</div>
      </div>
    </div>
  </div>

  <div class="card" style="background: #f8fafc; border: 1px solid #e2e8f0;">
    <div class="label">üí∞ Model Pricing Reference</div>
    <div style="font-size: 11px; color: #64748b; line-height: 1.4;" id="pricing-reference">
      <div style="margin: 4px 0;"><strong>GPT-5-Mini:</strong> $0.25 input / $2.00 output per 1M tokens</div>
      <div style="margin: 4px 0;"><strong>GPT-5-Nano:</strong> $0.05 input / $0.40 output per 1M tokens</div>
      <div style="margin: 4px 0; font-style: italic; color: #9ca3af;">Prices may vary - check OpenAI pricing page for latest rates</div>
    </div>
  </div>

  <div class="note">Tip: on mobile, use HTTPS (or localhost) for camera access.</div>
</div>

<!-- Hidden canvas for frame capture -->
<canvas id="canvas" class="hidden"></canvas>

<script>
(async () => {
  // ====== Config ======
  const RESPONSES_URL = 'https://api.openai.com/v1/responses';
  const TARGET_MAX_BASE64_BYTES = 100 * 1024;                      // ‚âà100 KB on wire
  const BINARY_BUDGET = Math.floor(TARGET_MAX_BASE64_BYTES * 3/4); // ‚âà75 KB binary (base64 +33%)
  const FRAME_WIDTH = 640;                                         // downscale width
  const JPEG_QUALITIES = [0.7, 0.6, 0.5, 0.45, 0.4, 0.35, 0.3];
  let SCAN_INTERVAL_MS = 100;                                      // fixed interval, fast mode

  // ====== Model Configuration ======
  const MODEL_PRICING = {
    'gpt-5-mini': {
      inputCost: 0.25 / 1000000,  // $0.25 per 1M input tokens
      outputCost: 2.00 / 1000000, // $2.00 per 1M output tokens
      displayName: 'GPT-5-Mini'
    },
    'gpt-5-nano': {
      inputCost: 0.05 / 1000000,  // $0.05 per 1M input tokens
      outputCost: 0.40 / 1000000, // $0.40 per 1M output tokens
      displayName: 'GPT-5-Nano'
    }
  };

  function getCurrentModel() {
    return elModel ? elModel.value : getSavedModel();
  }

  // ====== Elements ======
  const elVideo = document.getElementById('video');
  const elCanvas = document.getElementById('canvas');
  const elModel  = document.getElementById('model');
  const elFacing = document.getElementById('facing');
  const elStart  = document.getElementById('startBtn');
  const elStop   = document.getElementById('stopBtn');
  const elAPI    = document.getElementById('apiBtn');
  const elStatus = document.getElementById('status');
  const elOCR    = document.getElementById('ocr');
  const elMeta   = document.getElementById('meta');
  const elMetrics = document.getElementById('metrics-display');

  // ====== State ======
  let stream = null;
  let running = false;
  let inflight = false;

  // ====== Cumulative Token Tracking ======
  let cumulativeTokens = {
    input: 0,
    output: 0,
    total: 0
  };

  // ====== Cumulative Cost Tracking ======
  let cumulativeCosts = {
    input: 0,
    output: 0,
    total: 0
  };

  // ====== Cumulative API Time Tracking ======
  let cumulativeApi = {
    total: 0,
    count: 0
  };

  // ====== IndexedDB for OCR History ======
  const DB_NAME = 'OCRHistoryDB';
  const DB_VERSION = 1;
  const STORE_NAME = 'ocr_results';
  let db = null;

  // Initialize IndexedDB
  async function initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        db = request.result;
        resolve(db);
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
          store.createIndex('timestamp', 'timestamp', { unique: false });
        }
      };
    });
  }

  // Save OCR result to history
  async function saveToHistory(text, usage, api_ms, blob_size) {
    if (!db) await initDB();

    const record = {
      text: text,
      usage: usage,
      api_ms: api_ms,
      blob_size: blob_size,
      timestamp: new Date().toISOString()
    };

    return new Promise((resolve, reject) => {
      const transaction = db.transaction([STORE_NAME], 'readwrite');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.add(record);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
    });
  }

  // Load OCR history
  async function loadHistory() {
    if (!db) await initDB();

    return new Promise((resolve, reject) => {
      const transaction = db.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const index = store.index('timestamp');
      const request = index.openCursor(null, 'prev'); // Most recent first

      const results = [];
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(results);
        }
      };

      request.onerror = () => reject(request.error);
    });
  }

  // Display history in UI
  async function displayHistory() {
    try {
      const history = await loadHistory();
      const historyList = document.getElementById('history-list');

      if (history.length === 0) {
        historyList.innerHTML = 'No previous captures';
        return;
      }

      const historyHTML = history.slice(0, 5).map((record, index) => {
        const date = new Date(record.timestamp).toLocaleTimeString();
        // Dynamic preview: longer for short text, shorter for long text
        const maxLength = record.text.length > 100 ? 40 : (record.text.length > 50 ? 60 : 80);
        const preview = record.text.length > maxLength ? record.text.substring(0, maxLength) + '...' : record.text;
        const fullText = record.text.replace(/"/g, '"'); // Escape quotes for title attribute
        return `<div class="history-item" style="margin: 2px 0; padding: 2px; border-bottom: 1px solid #eee; cursor: pointer;" onclick="showHistoryItem(${record.id})" title="${fullText}">
          <small style="color: #999;">${date}</small><br>
          <small>${preview.replace(/\n/g, ' ')}</small>
        </div>`;
      }).join('');

      historyList.innerHTML = historyHTML;
    } catch (error) {
      console.error('Error loading history:', error);
      document.getElementById('history-list').innerHTML = 'Error loading history';
    }
  }

  // Show specific history item
  function showHistoryItem(id) {
    const tx = db.transaction([STORE_NAME], 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const req = store.get(id);
    req.onsuccess = () => {
      if (req.result) elOCR.textContent = req.result.text;
    };
  }

  // Toggle metrics help display
  function toggleMetricsHelp() {
    const helpSection = document.getElementById('metrics-help');
    if (helpSection) {
      helpSection.style.display = helpSection.style.display === 'none' ? 'block' : 'none';
    }
  }

  // ====== API Key (localStorage) ======
  function getKey() { return localStorage.getItem('OPENAI_API_KEY') || ''; }
  function setKey(k){ k ? localStorage.setItem('OPENAI_API_KEY', k.trim()) : localStorage.removeItem('OPENAI_API_KEY'); }

  // ====== Model Selection (localStorage) ======
  function getSavedModel() { return localStorage.getItem('SELECTED_MODEL') || 'gpt-5-nano'; }
  function setSavedModel(model){ localStorage.setItem('SELECTED_MODEL', model); }
  async function ensureKey() {
    let k = getKey();
    if (!k) {
      k = prompt('Enter your OpenAI API key (sk-...)');
      if (k && k.trim()) setKey(k.trim());
      else { alert('API key required to proceed.'); throw new Error('no-api-key'); }
    }
    return k;
  }
  elAPI.addEventListener('click', () => {
    const cur = getKey();
    const next = prompt('Edit your OpenAI API key:', cur || '');
    if (next === null) return; // cancelled
    if (!next.trim()) {
      if (confirm('Clear saved API key?')) setKey('');
    } else {
      setKey(next.trim());
      alert('Saved.');
    }
  });

  // ====== Camera ======
  async function startCamera(facingMode='environment') {
    stopCamera();
    try {
      stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ exact:facingMode } }, audio:false });
    } catch {
      try { stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode }, audio:false }); }
      catch { stream = await navigator.mediaDevices.getUserMedia({ video:true, audio:false }); }
    }
    elVideo.srcObject = stream;
    await elVideo.play();

    const vw = elVideo.videoWidth || 1280;
    const vh = elVideo.videoHeight || 720;
    const scale = FRAME_WIDTH / vw;
    elCanvas.width  = Math.round(vw * scale);
    elCanvas.height = Math.round(vh * scale);
  }
  function stopCamera(){ if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } }
  elFacing.addEventListener('change', () => startCamera(elFacing.value).catch(console.warn));

  // ====== Capture & Compression ======
  function drawFrame(){ elCanvas.getContext('2d').drawImage(elVideo,0,0,elCanvas.width,elCanvas.height); }
  function blobToDataURL(blob){
    return new Promise((resolve,reject)=>{ const fr=new FileReader(); fr.onload=()=>resolve(fr.result); fr.onerror=reject; fr.readAsDataURL(blob); });
  }
  async function compressToBudget(){
    drawFrame();
    for (let q of JPEG_QUALITIES){
      const blob = await new Promise(res=>elCanvas.toBlob(res,'image/webp',q));
      if (!blob) throw new Error('toBlob failed');
      if (blob.size <= BINARY_BUDGET) return { blob, quality:q };
    }
    // downscale once more and try again
    const tmp = document.createElement('canvas');
    tmp.width = Math.round(elCanvas.width * 0.85);
    tmp.height= Math.round(elCanvas.height* 0.85);
    tmp.getContext('2d').drawImage(elCanvas,0,0,tmp.width,tmp.height);
    for (let q of JPEG_QUALITIES){
      const blob = await new Promise(res=>tmp.toBlob(res,'image/webp',q));
      if (!blob) throw new Error('toBlob failed (2)');
      if (blob.size <= BINARY_BUDGET){
        elCanvas.width = tmp.width; elCanvas.height = tmp.height;
        elCanvas.getContext('2d').drawImage(elVideo,0,0,elCanvas.width,elCanvas.height);
        return { blob, quality:q };
      }
    }
    const fallbackBlob = await new Promise(res=>tmp.toBlob(res,'image/webp',JPEG_QUALITIES.at(-1)));
    return { blob:fallbackBlob, quality:JPEG_QUALITIES.at(-1) };
  }

  // ====== Cost calculation ======
  function calculateCost(usage) {
    if (!usage || !usage.total_tokens) {
      return {
        main: '‚Äî',
        breakdown: 'No usage data available',
        indicator: '',
        indicatorClass: '',
        inputCost: 0,
        outputCost: 0,
        totalCost: 0
      };
    }

    const currentModel = getCurrentModel();
    const modelConfig = MODEL_PRICING[currentModel];

    if (!modelConfig) {
      return {
        main: '‚Äî',
        breakdown: 'Unknown model pricing',
        indicator: '',
        indicatorClass: '',
        inputCost: 0,
        outputCost: 0,
        totalCost: 0
      };
    }

    const inputTokens = usage.input_tokens || 0;
    const outputTokens = usage.output_tokens || 0;
    const totalTokens = usage.total_tokens;

    const inputCost = inputTokens * modelConfig.inputCost;
    const outputCost = outputTokens * modelConfig.outputCost;
    const totalCost = inputCost + outputCost;

    // Format costs for display
    const formatCost = (cost) => {
      if (cost < 0.001) return cost.toFixed(8);
      if (cost < 0.01) return cost.toFixed(6);
      return cost.toFixed(4);
    };

    const mainCost = `$${formatCost(totalCost)}`;
    const breakdown = `input ${inputTokens} √ó $${modelConfig.inputCost.toFixed(8)} + output ${outputTokens} √ó $${modelConfig.outputCost.toFixed(8)}`;
    const indicator = `${totalTokens} tokens`;

    // Determine cost level for color coding
    let indicatorClass = 'cost-low';
    if (totalCost > 0.01) indicatorClass = 'cost-high';
    else if (totalCost > 0.001) indicatorClass = 'cost-medium';

    return {
      main: mainCost,
      breakdown: breakdown,
      indicator: indicator,
      indicatorClass: indicatorClass,
      inputCost: inputCost,
      outputCost: outputCost,
      totalCost: totalCost
    };
  }

  // ====== OCR Response Validation ======
  function validateOCRResponse(text) {
    if (typeof text !== 'string') return '_no_valid_text_';

    const normalized = text.trim();
    if (normalized.length === 0) return '_no_valid_text_';

    // Âà§Êñ∑ÊòØÂê¶ÂåÖÂê´Ëá≥Â∞ë‰∏ÄÂÄãËã±ÊñáÂ≠óÊØçÊàñÊï∏Â≠ó
    const hasAlphaNum = /[A-Za-z0-9]/.test(normalized);
    if (!hasAlphaNum) return '_no_valid_text_';

    return normalized;
  }

  // ====== OpenAI Responses API call (browser) ‚Äî General OCR ======
  async function callResponsesAPI(dataUrl){
    const key = getKey(); if (!key) throw new Error('no-api-key');

    const currentModel = getCurrentModel();
    const modelConfig = MODEL_PRICING[currentModel];

    const payload = {
      model: currentModel,
      // Performance optimizations for faster OCR
      reasoning: {
        effort: "minimal"
      },
      text: {
        verbosity: "low",
        format: {
          type: 'json_schema',
          name: 'ocr_text',
          schema: {
            type: 'object',
            properties: { text: { type:'string', minLength: 1 } },
            required: ['text'],
            additionalProperties: false
          },
          strict: true
        }
      },
      input: [{
        role: 'user',
        content: [
          { type:'input_text',
            text:'Extract ALL readable text from this image ONLY. If no readable text is found (blurred/too small/none), reply strictly with JSON {"text":"_no_valid_text_"}. Do not describe the image, do not explain, do not add anything else. Your output must always be valid JSON that matches the provided schema.' },
          { type:'input_image', image_url: dataUrl }
        ]
      }]
    };

    const t0 = performance.now();
    const res = await fetch(RESPONSES_URL, {
      method:'POST',
      headers:{ 'Authorization':`Bearer ${key}`, 'Content-Type':'application/json' },
      body: JSON.stringify(payload)
    });
    const t1 = performance.now();
    const data = await res.json();

    if (!res.ok){
      const msg = data?.error?.message || `HTTP ${res.status}`;
      throw new Error(msg);
    }

    // 1) Preferred structured parse
    let textOut = data?.output_parsed?.text || '';

    // 2) Fallback: walk output -> message -> content -> output_text
    if (!textOut && Array.isArray(data.output)) {
      for (const item of data.output) {
        if (item?.type === 'message' && Array.isArray(item.content)) {
          for (const c of item.content) {
            if (c?.type === 'output_text' && typeof c.text === 'string') {
              // Try JSON first
              try {
                const parsed = JSON.parse(c.text);
                if (parsed && typeof parsed.text === 'string') { textOut = parsed.text; break; }
              } catch {
                // Not JSON ‚Äî validate raw text to filter out descriptive content
                const validatedText = validateOCRResponse(c.text);
                 if (validatedText !== '_no_valid_text_') {
                   textOut = validatedText;
                   break;
                 }
                break;
              }
            }
          }
        }
        if (textOut) break;
      }
    }

    // 3) Final fallback
    if (!textOut) textOut = data?.output_text || '';

    // Apply strict validation to ensure proper format
    textOut = validateOCRResponse(textOut);

    // Light normalization (only if not _no_valid_text_)
    if (textOut !== '_no_valid_text_' && typeof textOut === 'string') {
      textOut = textOut.replace(/\n{3,}/g, '\n\n').trim();
    }

    return {
      text: textOut,
      usage: data?.usage || null,
      api_ms: Math.round(t1 - t0)
    };
  }

  // ====== Loop ======
  function setStatus(s){ elStatus.textContent = s; }
  async function scanOnce(retryCount = 0){
    if (!running || inflight) return;
    if (!elVideo.srcObject){ setStatus('camera unavailable'); return; }

    inflight = true;
    try{
      setStatus('capturing‚Ä¶');
      const { blob, quality } = await compressToBudget();
      const dataUrl = await blobToDataURL(blob);
      if (dataUrl.length > (TARGET_MAX_BASE64_BYTES * 1.1)){
        console.warn('dataURL > target size:', (dataUrl.length/1024).toFixed(1), 'KB');
      }

      setStatus('sending‚Ä¶');
      const out = await callResponsesAPI(dataUrl);

      elOCR.textContent = out.text || '‚Äî';
      const tok = out.usage?.total_tokens ?? 'n/a';

      // Update cumulative API time tracking
      cumulativeApi.total += out.api_ms;
      cumulativeApi.count++;
      const avgApi = Math.round(cumulativeApi.total / cumulativeApi.count);

      // Update metrics display
      elMetrics.textContent = `üìä bin:${(blob.size/1024|0)}KB ¬∑ api:${out.api_ms}ms ¬∑ avg:${avgApi}ms ¬∑ interval:${SCAN_INTERVAL_MS}ms ¬∑ tokens:${tok}`;

      // Update token table if usage data is available
      if (out.usage) {
        const tableContainer = document.getElementById('token-table-container');
        const inputTokens = out.usage.input_tokens || 0;
        const outputTokens = out.usage.output_tokens || 0;
        const totalTokens = inputTokens + outputTokens; // Calculate sum to verify

        // Update current scan row
        document.getElementById('input-tokens').textContent = inputTokens.toLocaleString();
        document.getElementById('output-tokens').textContent = outputTokens.toLocaleString();
        document.getElementById('total-tokens').textContent = totalTokens.toLocaleString();

        // Accumulate session totals
        cumulativeTokens.input += inputTokens;
        cumulativeTokens.output += outputTokens;
        cumulativeTokens.total += totalTokens;

        // Update cumulative row
        document.getElementById('cumulative-input').textContent = cumulativeTokens.input.toLocaleString();
        document.getElementById('cumulative-output').textContent = cumulativeTokens.output.toLocaleString();
        document.getElementById('cumulative-total').textContent = cumulativeTokens.total.toLocaleString();

        tableContainer.style.display = 'block';
      }

      // Update API time table
      if (cumulativeApi.count > 0) {
        const apiTimeContainer = document.getElementById('api-time-container');
        document.getElementById('current-api-time').textContent = `${out.api_ms}ms`;
        document.getElementById('average-api-time').textContent = `${avgApi}ms`;
        document.getElementById('api-scan-count').textContent = cumulativeApi.count.toLocaleString();
        apiTimeContainer.style.display = 'block';
      }

      // Calculate and display cost estimate
      const costData = calculateCost(out.usage);
      document.getElementById('cost-main').textContent = costData.main;
      document.getElementById('cost-breakdown').textContent = costData.breakdown;
      const indicator = document.getElementById('cost-indicator');
      indicator.textContent = costData.indicator;
      indicator.className = `cost-indicator ${costData.indicatorClass}`;

      // Update cumulative costs
      cumulativeCosts.input += costData.inputCost;
      cumulativeCosts.output += costData.outputCost;
      cumulativeCosts.total += costData.totalCost;

      // Display cumulative costs
      const cumulativeSection = document.getElementById('cumulative-cost-section');
      document.getElementById('cumulative-cost-main').textContent = `$${cumulativeCosts.total.toFixed(8)}`;
      document.getElementById('cumulative-cost-breakdown').textContent = `Session: ${cumulativeTokens.input}√ó${(cumulativeCosts.input/cumulativeTokens.input).toFixed(8)} + ${cumulativeTokens.output}√ó${(cumulativeCosts.output/cumulativeTokens.output).toFixed(8)}`;
      cumulativeSection.style.display = 'block';

      // Save to history and update display
      await saveToHistory(out.text, out.usage, out.api_ms, blob.size);
      await displayHistory();

      // Fixed scan interval (fast mode)
      SCAN_INTERVAL_MS = 100;

      setStatus('ok');
    } catch(err){
      console.error(err);

      // Retry logic with visual feedback
      const maxRetries = 2;
      if (retryCount < maxRetries) {
        setStatus(`retrying‚Ä¶ (${retryCount + 1}/${maxRetries})`);
        elMeta.textContent = err?.message || 'error - retrying...';

        // Wait before retry with exponential backoff
        setTimeout(() => {
          inflight = false;
          if (running) scanOnce(retryCount + 1);
        }, Math.min(1000 * Math.pow(2, retryCount), 5000)); // Max 5 second delay
        return;
      }

      // Final failure after retries
      setStatus('error');
      elMeta.textContent = err?.message || 'error';
    } finally {
      inflight = false;
      if (running) setTimeout(scanOnce, SCAN_INTERVAL_MS);
    }
  }

  async function startAll(){
    try {
      await ensureKey();
      await initDB(); // Initialize database
    } catch { return; }
    if (running) return;
    setStatus('starting camera‚Ä¶');
    await startCamera(elFacing.value);
    running = true;
    setStatus('scanning‚Ä¶');
    scanOnce();
  }
  function stopAll(){
    running = false;
    setStatus('stopped');
    stopCamera(); // Close camera stream when stopping

    // Reset cumulative tracking for new session
    cumulativeTokens = { input: 0, output: 0, total: 0 };
    cumulativeCosts = { input: 0, output: 0, total: 0 };
    cumulativeApi = { total: 0, count: 0 };

    // Hide tracking UI sections
    const tableContainer = document.getElementById('token-table-container');
    const cumulativeCostSection = document.getElementById('cumulative-cost-section');
    const apiTimeContainer = document.getElementById('api-time-container');
    tableContainer.style.display = 'none';
    cumulativeCostSection.style.display = 'none';
    apiTimeContainer.style.display = 'none';

    // Clear current OCR display but keep history for reference
    elOCR.textContent = '‚Äî';
  }

  // ====== UI ======
  elStart.addEventListener('click', startAll);
  elStop.addEventListener('click', stopAll);
  elModel.addEventListener('change', () => {
    // Save model selection to localStorage
    setSavedModel(elModel.value);
    // Reset cumulative tracking when switching models
    cumulativeTokens = { input: 0, output: 0, total: 0 };
    cumulativeCosts = { input: 0, output: 0, total: 0 };
    cumulativeApi = { total: 0, count: 0 };
    const tableContainer = document.getElementById('token-table-container');
    const cumulativeCostSection = document.getElementById('cumulative-cost-section');
    const apiTimeContainer = document.getElementById('api-time-container');
    tableContainer.style.display = 'none';
    cumulativeCostSection.style.display = 'none';
    apiTimeContainer.style.display = 'none';
  });
  window.addEventListener('load', () => {
    // Load saved model selection
    if (elModel) {
      elModel.value = getSavedModel();
    }
    startAll().catch(console.warn);
  });
})();
</script>
</body>
</html>
